# 第4章 处理器体系结构

## 核心概念

### Y86-64 指令集架构
- 简化的 x86-64 子集
- 包含常用指令: mov, push, pop, add, sub, jmp, call, ret等
- 定义了程序员可见的处理器状态

### 硬件组织
- **CPU**: 中央处理单元
- **ALU**: 算术逻辑单元
- **寄存器**: 存储临时数据
- **PC**: 程序计数器
- **条件码**: ZF, SF, OF

### 指令执行阶段
1. **取指(Fetch)**: 从内存读取指令
2. **译码(Decode)**: 解释指令
3. **执行(Execute)**: 执行操作
4. **访存(Memory)**: 读写内存
5. **写回(Write Back)**: 写入寄存器
6. **更新PC(PC Update)**: 更新程序计数器

## 难点解析

### 顺序实现
- 时钟周期长
- 资源利用率低
- 性能受限

### 流水线实现
- **流水线阶段**: F, D, E, M, W
- **流水线冒险**:
  - 数据冒险: 依赖关系
  - 控制冒险: 跳转指令
  - 冒险处理: 暂停、转发、预测

### 性能指标
- **CPI**: 每指令平均周期数
- **吞吐量**: 每秒执行指令数
- **加速比**: 改进前后性能比

## 实践联系

### 性能优化
- 理解处理器行为有助于优化代码
- 减少数据依赖可以提高流水线效率
- 避免控制冒险可以提高性能

### 代码示例
```c
// 低效代码(有数据依赖)
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += a[i];  // 依赖sum
}

// 优化后的代码(循环展开)
int sum = 0;
int i;
for (i = 0; i < n - 3; i += 4) {
    sum += a[i];
    sum += a[i + 1];
    sum += a[i + 2];
    sum += a[i + 3];
}
for (; i < n; i++) {
    sum += a[i];
}
```

## 思考问题

1. 为什么流水线能提高性能？
2. 如何处理分支预测失败？
3. 超标量处理器是如何工作的？

## 延伸阅读

- [Hennessy & Patterson - Computer Architecture](https://www.elsevier.com/books/computer-architecture/hennessy/978-0-12-383872-8)
- [处理器性能分析工具](https://perf.wiki.kernel.org/)
